<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cuestionario de Seguro Validado por IA</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --brand-primary: #46199B;
      --brand-secondary: #7757C1;
      --brand-highlight: #C5B8DF;
      --brand-background: #F7F7F7;
      --brand-text: #111111;
      --brand-text-secondary: #737271;
      --brand-border: #A0A0A0;
    }
    body {
      font-family: "FSAlbertW05-Bold", "Open Sans", Helvetica, Arial, sans-serif;
    }
    @keyframes pulse-ring {
      0% { transform: scale(0.95); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.7; }
      100% { transform: scale(0.95); opacity: 1; }
    }
    .pulse-ring { animation: pulse-ring 1.5s ease-in-out infinite; }
    
    @keyframes sound-wave {
      0%, 100% { height: 8px; }
      50% { height: 24px; }
    }
    .sound-bar { animation: sound-wave 0.5s ease-in-out infinite; }
    .sound-bar:nth-child(2) { animation-delay: 0.1s; }
    .sound-bar:nth-child(3) { animation-delay: 0.2s; }
    .sound-bar:nth-child(4) { animation-delay: 0.3s; }
    .sound-bar:nth-child(5) { animation-delay: 0.4s; }
  </style>
</head>
<body class="min-h-screen bg-[var(--brand-background)] text-[var(--brand-text)] font-sans">

  <div id="app"></div>

  <script>
    // ============================================================================
    // SERVER CONFIGURATION (loaded from backend)
    // ============================================================================
    
    let serverConfig = {
      ttsEnabled: false,
      validationEnabled: false,
      validationProvider: 'anthropic',
    };

    // Load config from server
    async function loadConfig() {
      try {
        const response = await fetch('/api/config');
        serverConfig = await response.json();
        console.log('Server config loaded:', serverConfig);
      } catch (error) {
        console.error('Failed to load server config:', error);
      }
    }

    // ============================================================================
    // QUESTION SCRIPT - Exactly what will be asked, in exact order
    // ============================================================================
    
    const QUESTIONS = [
      // === Customer Identification ===
      {
        id: 'cust_id_first_name',
        section: 'Bienvenida',
        question: '¿Puedo tener su primer nombre?',
        type: 'open',
      },
      {
        id: 'cust_id_last_name',
        section: 'Bienvenida',
        question: '¿Puedo tener su apellido?',
        type: 'open',
      },
      {
        id: 'cust_id_gender',
        section: 'Bienvenida',
        question: '¿Puedo tener su género físico?',
        type: 'open',
      },

      // === PRIMARY MEDICAL PROVIDER ===
      {
        id: 'pmv.has_primary_provider',
        section: 'Proveedor Médico Primario',
        question: '¿Tiene un proveedor médico primario?',
        type: 'yes_no',
        onNo: 'pmv.other_provider_reason',
      },
      {
        id: 'pmv.last_visit_reason',
        section: 'Proveedor Médico Primario',
        question: '¿Cuál fue el motivo de su última visita o consulta con su proveedor médico primario?',
        type: 'open',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
      },
      {
        id: 'pmv.last_visit_date',
        section: 'Proveedor Médico Primario',
        question: '¿Cuándo fue esta visita?',
        type: 'date',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
      },
      {
        id: 'pmv.last_visit_results',
        section: 'Proveedor Médico Primario',
        question: '¿Cuáles fueron los resultados?',
        type: 'open',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
      },
      {
        id: 'pmv.last_visit_treatment',
        section: 'Proveedor Médico Primario',
        question: '¿Qué tratamiento o medicamentos le recetaron?',
        type: 'open',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
      },
      {
        id: 'pmv.last_visit_provider_name',
        section: 'Proveedor Médico Primario',
        question: '¿Sabe el nombre del proveedor médico que vio para este chequeo?',
        type: 'open',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
      },
      {
        id: 'pmv.other_provider_reason',
        section: 'Proveedor Médico Primario',
        question: '¿Aparte de su proveedor médico primario, cuál fue el motivo de su última visita o consulta con cualquier proveedor médico?',
        type: 'open',
        requires: { id: 'pmv.has_primary_provider', answer: 'NO' },
      },
      
      // === NEUROLOGICAL ===
      {
        id: 'neuro.gateway',
        section: 'Neurológico',
        question: '¿Alguna vez ha sido diagnosticado con algún trastorno o enfermedad del cerebro, médula espinal o sistema nervioso?',
        type: 'yes_no',
        onNo: 'psych.gateway',
      },
      {
        id: 'neuro.dx_list',
        section: 'Neurológico',
        question: '¿Qué condición(es) neurológica(s) específica(s) fueron diagnosticadas?',
        type: 'open',
        requires: { id: 'neuro.gateway', answer: 'YES' },
      },
      {
        id: 'neuro.dx_dates',
        section: 'Neurológico',
        question: '¿Fecha del primer diagnóstico y fecha de los síntomas más recientes?',
        type: 'open',
        requires: { id: 'neuro.gateway', answer: 'YES' },
      },
      {
        id: 'neuro.hosp_impairment',
        section: 'Neurológico',
        question: '¿Alguna hospitalización, visita a urgencias, convulsiones/episodios o limitaciones funcionales en los últimos 5 años?',
        type: 'open',
        requires: { id: 'neuro.gateway', answer: 'YES' },
      },
      
      // === PSYCHIATRIC ===
      {
        id: 'psych.gateway',
        section: 'Psiquiátrico',
        question: '¿Alguna vez ha sido diagnosticado con algún trastorno o enfermedad psiquiátrica, nerviosa, emocional o mental?',
        type: 'yes_no',
        onNo: 'eent.gateway',
      },
      {
        id: 'psych.dx_list',
        section: 'Psiquiátrico',
        question: '¿Qué diagnóstico(s) aplican? (por ejemplo, TDAH, ansiedad, depresión, bipolar, TEPT, etc.)',
        type: 'open',
        requires: { id: 'psych.gateway', answer: 'YES' },
      },
      {
        id: 'psych.dx_dates',
        section: 'Psiquiátrico',
        question: '¿Cuándo fue diagnosticada esta condición?',
        type: 'date',
        requires: { id: 'psych.gateway', answer: 'YES' },
      },
      {
        id: 'psych.current_tx',
        section: 'Psiquiátrico',
        question: '¿Está actualmente en tratamiento o tomando medicamentos para la condición?',
        type: 'yes_no',
        requires: { id: 'psych.gateway', answer: 'YES' },
      },
      {
        id: 'psych.meds_count',
        section: 'Psiquiátrico',
        question: '¿Cuántos medicamentos toma, si alguno?',
        type: 'number',
        requires: { id: 'psych.current_tx', answer: 'YES' },
      },
      {
        id: 'psych.meds_names',
        section: 'Psiquiátrico',
        question: '¿Cuál es/son el/los nombre(s) del/de los medicamento(s)?',
        type: 'open',
        requires: { id: 'psych.current_tx', answer: 'YES' },
      },
      {
        id: 'psych.disability_hosp',
        section: 'Psiquiátrico',
        question: '¿En los últimos 3 años: algún pago por discapacidad, más de 1 semana de trabajo perdido, urgencias/hospitalización o autolesión/ideación suicida?',
        type: 'open',
        requires: { id: 'psych.gateway', answer: 'YES' },
      },
      {
        id: 'psych.provider_name',
        section: 'Psiquiátrico',
        question: '¿Sabe el nombre del proveedor médico que vio para esta condición?',
        type: 'open',
        requires: { id: 'psych.gateway', answer: 'YES' },
      },
      {
        id: 'psych.med_changes_12m',
        section: 'Psiquiátrico',
        question: '¿Algún cambio de medicamento, aumento de dosis o nuevas recetas en los últimos 12 meses?',
        type: 'open',
        requires: { id: 'psych.gateway', answer: 'YES' },
      },
      {
        id: 'psych.comorbid',
        section: 'Psiquiátrico',
        question: '¿Algún diagnóstico de salud mental comórbido o síntomas activos (ataques de pánico, episodios de depresión mayor, manía, etc.)?',
        type: 'open',
        requires: { id: 'psych.gateway', answer: 'YES' },
      },
      {
        id: 'psych.substance_misuse',
        section: 'Psiquiátrico',
        question: '¿Alguna vez ha sido diagnosticado con algún historial de abuso de sustancias, dependencia o mal uso de medicamentos recetados?',
        type: 'open',
        requires: { id: 'psych.gateway', answer: 'YES' },
      },
      
      // === EENT ===
      {
        id: 'eent.gateway',
        section: 'Ojos, Oídos, Nariz y Garganta',
        question: '¿Algún trastorno o enfermedad de los ojos, oídos, nariz o garganta?',
        type: 'yes_no',
        onNo: 'cardio.gateway',
      },
      {
        id: 'eent.dx',
        section: 'Ojos, Oídos, Nariz y Garganta',
        question: '¿Qué condición (por ejemplo, pérdida auditiva, glaucoma, sinusitis crónica)?',
        type: 'open',
        requires: { id: 'eent.gateway', answer: 'YES' },
      },
      {
        id: 'eent.treatment',
        section: 'Ojos, Oídos, Nariz y Garganta',
        question: '¿Está la condición corregida/tratada (cirugía, audífonos, lentes, medicamento)?',
        type: 'open',
        requires: { id: 'eent.gateway', answer: 'YES' },
      },
      {
        id: 'eent.impairment',
        section: 'Ojos, Oídos, Nariz y Garganta',
        question: '¿Afecta las actividades diarias, la conducción o las tareas laborales?',
        type: 'open',
        requires: { id: 'eent.gateway', answer: 'YES' },
      },
      
      // === CARDIOVASCULAR ===
      {
        id: 'cardio.gateway',
        section: 'Cardiovascular',
        question: '¿Alguna vez ha sido diagnosticado con algún trastorno o enfermedad del corazón, vasos sanguíneos o sistema circulatorio (incluyendo presión arterial alta/colesterol alto)?',
        type: 'yes_no',
        onNo: 'resp.gateway',
      },
      {
        id: 'cardio.dx',
        section: 'Cardiovascular',
        question: '¿Qué diagnóstico(s) aplican? (por ejemplo, hipertensión, hiperlipidemia, enfermedad arterial coronaria, arritmia)',
        type: 'open',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      {
        id: 'cardio.dx_date',
        section: 'Cardiovascular',
        question: 'When was the condition diagnosed?',
        type: 'date',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      {
        id: 'cardio.bp_known',
        section: 'Cardiovascular',
        question: '¿Sabe su lectura de presión arterial más reciente?',
        type: 'yes_no',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      {
        id: 'cardio.on_meds',
        section: 'Cardiovascular',
        question: '¿Está tomando medicamento para esta condición?',
        type: 'yes_no',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      {
        id: 'cardio.bp_sys',
        section: 'Cardiovascular',
        question: '¿Presión arterial sistólica más reciente (número superior)?',
        type: 'number',
        requires: { id: 'cardio.bp_known', answer: 'YES' },
      },
      {
        id: 'cardio.bp_dia',
        section: 'Cardiovascular',
        question: '¿Presión arterial diastólica más reciente (número inferior)?',
        type: 'number',
        requires: { id: 'cardio.bp_known', answer: 'YES' },
      },
      {
        id: 'cardio.provider_name',
        section: 'Cardiovascular',
        question: '¿Sabe el nombre del proveedor médico que vio para esta condición?',
        type: 'open',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      {
        id: 'cardio.control_duration',
        section: 'Cardiovascular',
        question: '¿Cuánto tiempo han estado controladas las lecturas aproximadamente al nivel actual?',
        type: 'open',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      {
        id: 'cardio.comorbid',
        section: 'Cardiovascular',
        question: '¿Alguna condición relacionada (diabetes, enfermedad renal, derrame cerebral/AIT, enfermedad cardíaca)?',
        type: 'open',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      {
        id: 'cardio.testing_hosp',
        section: 'Cardiovascular',
        question: '¿Algún dolor en el pecho, dificultad para respirar con el esfuerzo, EKG/eco/prueba de esfuerzo anormal, visita a urgencias u hospitalización?',
        type: 'open',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      
      // === RESPIRATORY ===
      {
        id: 'resp.gateway',
        section: 'Respiratorio',
        question: '¿Alguna vez ha sido diagnosticado con algún trastorno o enfermedad del sistema respiratorio (asma, EPOC, apnea del sueño, etc.)?',
        type: 'yes_no',
        onNo: 'END',
      },
      {
        id: 'resp.dx',
        section: 'Respiratorio',
        question: '¿Qué condición (asma, apnea del sueño, EPOC, bronquitis crónica, etc.)?',
        type: 'open',
        requires: { id: 'resp.gateway', answer: 'YES' },
      },
      {
        id: 'resp.severity',
        section: 'Respiratorio',
        question: '¿Cómo calificaría la gravedad (leve/moderada/grave) y el control actual?',
        type: 'open',
        requires: { id: 'resp.gateway', answer: 'YES' },
      },
      {
        id: 'resp.exacerbations',
        section: 'Respiratorio',
        question: '¿Alguna hospitalización/visita a urgencias, ráfagas de esteroides, uso de CPAP/terapia de oxígeno en los últimos 5 años?',
        type: 'open',
        requires: { id: 'resp.gateway', answer: 'YES' },
      },
    ];
    const INTRO_MESSAGE =
      "Hola y gracias por elegir Protective Life. Durante esta llamada telefónica le haré varias preguntas sobre su salud, medicamentos, algunas finanzas e incluso viajes pasados o futuros. Esta información nos ayudará a entender su situación de salud y financiera en relación con el seguro de vida.";

    const COMPLETION_MESSAGE = 
      "Gracias por elegir Protective Life. " +
      "Sus respuestas han sido registradas.d. " +
      "Un representante revisará su información y se pondrá en contacto con usted en un plazo de 24 a 48 horas.";
  
    const MAX_RETRIES = 3;
    const MAX_EXPLAINS = 2;

    // ============================================================================
    // TEXT-TO-SPEECH SERVICE
    // ============================================================================
    
    class TTSService {
      constructor() {
        this.audioContext = null;
        this.currentSource = null;
        this.isSpeaking = false;
      }

      async speak(text) {
        this.isSpeaking = true;
        
        try {
          if (serverConfig.ttsEnabled) {
            await this.speakElevenLabs(text);
          } else {
            await this.speakWebSpeech(text);
          }
        } finally {
          this.isSpeaking = false;
        }
      }

      async speakElevenLabs(text) {
        try {
          const response = await fetch('/api/tts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text }),
          });

          if (!response.ok) {
            console.error('TTS API error, falling back to Web Speech');
            return this.speakWebSpeech(text);
          }

          const arrayBuffer = await response.arrayBuffer();
          
          if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }

          const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
          
          return new Promise((resolve) => {
            const source = this.audioContext.createBufferSource();
            this.currentSource = source;
            source.buffer = audioBuffer;
            source.connect(this.audioContext.destination);
            source.onended = () => {
              this.currentSource = null;
              resolve();
            };
            source.start(0);
          });
        } catch (error) {
          console.error('ElevenLabs error:', error);
          return this.speakWebSpeech(text);
        }
      }

      speakWebSpeech(text) {
        return new Promise((resolve) => {
          window.speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 0.9;
          utterance.pitch = 1;
          utterance.onend = resolve;
          utterance.onerror = () => resolve();
          window.speechSynthesis.speak(utterance);
        });
      }

      stop() {
        this.isSpeaking = false;
        if (this.currentSource) {
          try { this.currentSource.stop(); } catch (e) {}
          this.currentSource = null;
        }
        window.speechSynthesis.cancel();
      }
    }

    // ============================================================================
    // SPEECH RECOGNITION SERVICE
    // ============================================================================
    
    class ASRService {
      constructor() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        this.recognition = SpeechRecognition ? new SpeechRecognition() : null;
        
        if (this.recognition) {
          this.recognition.continuous = false;
          this.recognition.interimResults = false;
          this.recognition.lang = 'es-ES';
          this.recognition.maxAlternatives = 1;
        }
      }

      isSupported() {
        return !!this.recognition;
      }

      listen(timeoutMs = 10000) {
        return new Promise((resolve, reject) => {
          if (!this.recognition) {
            reject(new Error('Speech recognition not supported'));
            return;
          }

          let resolved = false;
          let timeoutId = null;

          const cleanup = () => {
            if (timeoutId) clearTimeout(timeoutId);
          };

          this.recognition.onresult = (event) => {
            if (!resolved) {
              resolved = true;
              cleanup();
              resolve(event.results[0][0].transcript);
            }
          };

          this.recognition.onerror = (event) => {
            if (!resolved && event.error !== 'no-speech') {
              resolved = true;
              cleanup();
              reject(new Error(event.error));
            }
          };

          this.recognition.onend = () => {
            if (!resolved) {
              resolved = true;
              cleanup();
              resolve('');
            }
          };

          timeoutId = setTimeout(() => {
            if (!resolved) {
              resolved = true;
              this.recognition.stop();
              cleanup();
              resolve('');
            }
          }, timeoutMs);

          this.recognition.start();
        });
      }

      stop() {
        if (this.recognition) {
          try { this.recognition.stop(); } catch (e) {}
        }
      }
    }

    // ============================================================================
    // VALIDATION SERVICE (calls backend API)
    // ============================================================================
    
    class ValidationService {
      async validate(question, questionType, transcript, choices = null) {
        try {
          const response = await fetch('/api/validate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question, questionType, transcript, choices }),
          });

          if (!response.ok) {
            throw new Error('Validation API error');
          }

          return await response.json();
        } catch (error) {
          console.error('Validation error:', error);
          return { valid: false, normalized: null, explanation: null, repeat: false };
        }
      }
    }

    class WhyService {
      async explain(question, section, explainLevel = 1, previousExplanation = null) {
        try {
          const response = await fetch('/api/why', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question, section, explainLevel, previousExplanation }),
          });

          if (!response.ok) {
            throw new Error('Why API error');
          }

          return await response.json();
        } catch (error) {
          console.error('Why explanation error:', error);
          return { explanation: 'This helps us understand your medical history for your application.' };
        }
      }
    }
    // ============================================================================
    // FLOW CONTROLLER
    // ============================================================================
    
    class FlowController {
      constructor() {
        this.tts = new TTSService();
        this.asr = new ASRService();
        this.validator = new ValidationService();
        this.why = new WhyService();
        this.sessionId = 0;
        
        this.state = {
          status: 'idle',
          currentQuestionIndex: -1,
          answers: {},
          transcript: [],
          retryCount: 0,
          explainCounts: {},
          lastWhyExplanation: null,
          pendingAssistantMessage: null,
          error: null,
        };
        
        this.onStateChange = null;
      }

      setState(updates) {
        this.state = { ...this.state, ...updates };
        if (this.onStateChange) this.onStateChange(this.state);
      }

      findNextQuestionIndex(fromIndex, answers) {
        for (let i = fromIndex; i < QUESTIONS.length; i++) {
          const q = QUESTIONS[i];
          
          if (q.requires) {
            const dependentAnswer = answers[q.requires.id];
            if (dependentAnswer !== q.requires.answer) {
              continue;
            }
          }
          
          return i;
        }
        return -1;
      }

      handleSkipTo(skipToId, currentIndex, answers) {
        if (skipToId === 'END') return -1;
        
        const targetIndex = QUESTIONS.findIndex(q => q.id === skipToId);
        if (targetIndex !== -1) {
          return this.findNextQuestionIndex(targetIndex, answers);
        }
        return this.findNextQuestionIndex(currentIndex + 1, answers);
      }

      async askQuestion(questionIndex, options = {}) {
        const { preserveRetryCount = false, retryCountOverride = null } = options;
        const sessionId = this.sessionId;
        if (questionIndex < 0 || questionIndex >= QUESTIONS.length) {
          this.setState({ status: 'speaking', currentQuestionIndex: -1 });
          await this.speakAssistant(COMPLETION_MESSAGE, sessionId);
          if (this.sessionId !== sessionId) return;
          this.setState({ status: 'complete' });
          return;
        }

        const shouldResetWhy = questionIndex !== this.state.currentQuestionIndex;
        const shouldResetRetry = questionIndex !== this.state.currentQuestionIndex;
        const question = QUESTIONS[questionIndex];
        this.setState({ 
          status: 'speaking', 
          currentQuestionIndex: questionIndex,
          retryCount: retryCountOverride !== null
            ? retryCountOverride
            : (shouldResetRetry ? 0 : this.state.retryCount),
          lastWhyExplanation: shouldResetWhy ? null : this.state.lastWhyExplanation,
        });

        // Announce the Lifestyle and Medical Related questions
        const Lifestyle_and_Medical_Message = "A continuación repasaremos algunas preguntas relacionadas con el estilo de vida y la salud. Tenga en cuenta que se asume que las respuestas son según su mejor conocimiento. Para acelerar el proceso general de solicitud, nos gusta obtener toda la información posible por adelantado para eliminar cualquier demora.";
        if (questionIndex === 3) {
          this.state.transcript.push({ role: 'assistant', text: Lifestyle_and_Medical_Message });
          await this.tts.speak(Lifestyle_and_Medical_Message);
        }

        // Announce the Medical Conditions related questions
        const Medical_Conditions_Message = "Ahora repasaremos algunas condiciones médicas específicas. Le leeré algunas a la vez. Por favor háganme saber si ha tenido alguna de las condiciones para que podamos obtener información adicional donde sea necesario.";
        if (questionIndex === 10) {
          this.state.transcript.push({ role: 'assistant', text: Medical_Conditions_Message });
          await this.tts.speak(Medical_Conditions_Message);
        }

        await this.speakAssistant(question.question, sessionId);
        if (this.sessionId !== sessionId) return;

        this.setState({ status: 'listening' });
        
        try {
          const spokenAnswer = await this.asr.listen(15000);
          if (this.sessionId !== sessionId) return;
          
          if (!spokenAnswer) {
            if (this.state.retryCount < MAX_RETRIES) {
              const nextRetry = this.state.retryCount + 1;
              this.setState({ retryCount: nextRetry });
              await this.speakAssistant("No escuché nada. Déjeme repetir la pregunta.", sessionId);
              if (this.sessionId !== sessionId) return;
              return this.askQuestion(questionIndex, { preserveRetryCount: true, retryCountOverride: nextRetry });
            } else {
              await this.speakAssistant("Tengo problemas para escucharlo. Sigamos adelante.", sessionId);
              if (this.sessionId !== sessionId) return;
              this.state.answers[question.id] = 'NO_RESPONSE';
              return this.advanceToNextQuestion(questionIndex, 'NO_RESPONSE');
            }
          }

          const genderTranscript = question.id === 'cust_id_gender'
            ? this.normalizeGenderValue(spokenAnswer)
            : null;
          const transcriptAnswer = genderTranscript
            ? this.ensureTranscriptPeriod(genderTranscript)
            : spokenAnswer;
          this.state.transcript.push({ role: 'user', text: transcriptAnswer });
          
          if (this.isRepeatRequest(spokenAnswer)) {
            const acknowledgement = "Claro, repetiré la pregunta.";
            this.setState({ status: 'speaking' });
            await this.speakAssistant(acknowledgement, sessionId);
            if (this.sessionId !== sessionId) return;
            return this.askQuestion(questionIndex, { preserveRetryCount: true });
          }

          if (this.isWhyRequest(spokenAnswer)) {
            return this.handleWhy(questionIndex, question, sessionId);
          }

          if (question.id === 'cust_id_gender') {
            const genderValue = this.normalizeGenderValue(spokenAnswer);
            if (genderValue) {
              this.state.answers[question.id] = genderValue;
              this.setState({ status: 'speaking' });
              this.replaceLastUserTranscript(this.ensureTranscriptPeriod(genderValue));
              await this.speakAssistant("Gracias.", sessionId);
              if (this.sessionId !== sessionId) return;
              return this.advanceToNextQuestion(questionIndex, genderValue);
            }
          }

          return this.handleValidation(questionIndex, question, spokenAnswer, sessionId);

      } catch (error) {
        console.error('ASR Error:', error);
        this.setState({ error: error.message, status: 'idle' });
      }
    }

      async speakAssistant(text, sessionId) {
        this.setState({ pendingAssistantMessage: text });
        await this.tts.speak(text);
        if (this.sessionId !== sessionId) return;
        const updatedTranscript = this.state.transcript.concat({ role: 'assistant', text });
        this.setState({ transcript: updatedTranscript, pendingAssistantMessage: null });
      }

      replaceLastUserTranscript(text) {
        const updatedTranscript = [...this.state.transcript];
        for (let i = updatedTranscript.length - 1; i >= 0; i -= 1) {
          if (updatedTranscript[i].role === 'user') {
            updatedTranscript[i] = { ...updatedTranscript[i], text };
            break;
          }
        }
        this.setState({ transcript: updatedTranscript });
      }

      isRepeatRequest(transcript) {
        const normalized = transcript.toLowerCase().trim();
        const patterns = [
          'repeat',
          'say that again',
          'say it again',
          'can you repeat',
          'could you repeat',
          'please repeat',
          'repeat that',
          'what was that',
          'pardon',
          'come again',
          'say again',
          'repeat please',
          'huh',
          'sorry',
          'what did you say',
          'what was the question',
          'what',
          'can you repeat that',
          'say that',
          'say it',
        ];
        return patterns.some((p) => normalized.includes(p));
      }

      normalizeGenderValue(text) {
        if (!text) return null;
        const trimmed = text.trim();
        const lowered = trimmed.toLowerCase().replace(/[^a-z]/g, '');
        if (['male', 'mail', 'man', 'm'].includes(lowered)) {
          return 'Male';
        }
        if (['female', 'femail', 'woman', 'f'].includes(lowered)) {
          return 'Female';
        }
        if (['nonbinary', 'nb'].includes(lowered)) {
          return 'Non-binary';
        }
        if (['other', 'prefernot', 'na'].includes(lowered)) {
          return 'Other';
        }
        return null;
      }

      ensureTranscriptPeriod(text) {
        const trimmed = text.trim();
        return trimmed.endsWith('.') ? trimmed : `${trimmed}.`;
      }

      stripAcknowledgementPrefix(text) {
        if (!text) return text;
        const trimmed = text.trim();
        const patterns = [
          /^ok\b[\s,.-]*/i,
          /^okay\b[\s,.-]*/i,
          /^alright\b[\s,.-]*/i,
          /^all right\b[\s,.-]*/i,
          /^sure\b[\s,.-]*/i,
          /^got it\b[\s,.-]*/i,
          /^i get it\b[\s,.-]*/i,
          /^i understand\b[\s,.-]*/i,
          /^that makes sense\b[\s,.-]*/i,
        ];

        for (const pattern of patterns) {
          if (pattern.test(trimmed)) {
            const updated = trimmed.replace(pattern, '').trim();
            return updated.length > 0 ? updated : trimmed;
          }
        }

        return trimmed;
      }

      isWhyRequest(transcript) {
        const normalized = transcript.toLowerCase().trim();
        const patterns = [
          'why do i need to answer',
          'why do i need to answer that',
          'why do i have to answer',
          'why do i have to answer that',
          'why are you asking',
          'why do you need this',
          'why do you need to know',
          'why is this needed',
          'why is that needed',
          'what is this for',
          'why is this question',
          'why do i need to',
          'why do you ask',
          'why are you asking me',
          'why are you asking that',
          'why are you asking this',
          'can you explain',
          'could you explain',
          'explain that',
          'explain this',
          'can you explain that',
          'can you explain this',
          'help me understand',
          'why',
          'explain',
        ];
        return patterns.some((p) => normalized.includes(p));
      }

      isAgentRequest(transcript) {
        const normalized = transcript.toLowerCase().trim();
        const patterns = [
          'agent',
          'representative',
          'talk to a person',
          'talk to someone',
          'speak to someone',
          'human',
          'connect me',
        ];
        return patterns.some((p) => normalized.includes(p));
      }

      isContinueRequest(transcript) {
        const normalized = transcript.toLowerCase().trim();
        const patterns = [
          'continue',
          'keep going',
          'go on',
          'let\'s continue',
          'ready',
        ];
        return patterns.some((p) => normalized.includes(p));
      }

      getBridgeText(index) {
        const options = [
          "That's why we ask.",
          "I appreciate you asking.",
          "Thanks for checking on that.",
          "That context helps.",
        ];
        return options[index % options.length];
      }

      async handleWhy(questionIndex, question, sessionId) {
        const currentCount = this.state.explainCounts[question.id] || 0;
        const nextCount = currentCount + 1;
        const explainCounts = { ...this.state.explainCounts, [question.id]: nextCount };
        this.setState({ explainCounts });

        if (nextCount > MAX_EXPLAINS) {
          return this.handleHandoff(questionIndex, question, sessionId);
        }

        this.setState({ status: 'validating' });
        const whyResponse = await this.why.explain(
          question.question,
          question.section,
          nextCount,
          this.state.lastWhyExplanation || null
        );
        if (this.sessionId !== sessionId) return;

        const explanation = whyResponse.explanation || 'This helps us understand your medical history for your application.';
        this.setState({ lastWhyExplanation: explanation });
        const bridge = this.getBridgeText(nextCount - 1);
        const prompt = "Let me know if you want me to repeat it, or go ahead and answer.";
        const combined = `${explanation} ${bridge} ${prompt}`;

        this.setState({ status: 'speaking' });
        await this.speakAssistant(combined, sessionId);
        if (this.sessionId !== sessionId) return;

        this.setState({ status: 'listening' });
        const response = await this.asr.listen(15000);
        if (this.sessionId !== sessionId) return;

        if (!response) {
          if (this.state.retryCount < MAX_RETRIES) {
            const nextRetry = this.state.retryCount + 1;
            this.setState({ retryCount: nextRetry });
            return this.askQuestion(questionIndex, { preserveRetryCount: true, retryCountOverride: nextRetry });
          }
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

        this.state.transcript.push({ role: 'user', text: response });

        if (this.isRepeatRequest(response)) {
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

        if (this.isWhyRequest(response)) {
          return this.handleWhy(questionIndex, question, sessionId);
        }

        return this.handleValidation(questionIndex, question, response, sessionId);
      }

      async handleHandoff(questionIndex, question, sessionId) {
        const handoffMessage = "Quiero asegurarme de que lo hagamos bien. Puedo conectarlo con un agente, o podemos seguir adelante aquí. ¿Qué prefiere?";
        this.setState({ status: 'speaking' });
        await this.speakAssistant(handoffMessage, sessionId);
        if (this.sessionId !== sessionId) return;

        this.setState({ status: 'listening' });
        const response = await this.asr.listen(15000);
        if (this.sessionId !== sessionId) return;

        if (!response) {
          if (this.state.retryCount < MAX_RETRIES) {
            const nextRetry = this.state.retryCount + 1;
            this.setState({ retryCount: nextRetry });
            return this.askQuestion(questionIndex, { preserveRetryCount: true, retryCountOverride: nextRetry });
          }
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

        this.state.transcript.push({ role: 'user', text: response });

        if (this.isAgentRequest(response)) {
          this.setState({ status: 'handoff' });
          return;
        }

        if (this.isContinueRequest(response) || this.isRepeatRequest(response)) {
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

        if (this.isWhyRequest(response)) {
          return this.handleHandoff(questionIndex, question, sessionId);
        }

        return this.handleValidation(questionIndex, question, response, sessionId);
      }

      async handleValidation(questionIndex, question, spokenAnswer, sessionId) {
        this.setState({ status: 'validating' });
        const validation = await this.validator.validate(
          question.question,
          question.type,
          spokenAnswer,
          question.choices
        );
        if (this.sessionId !== sessionId) return;

        if (validation.repeat) {
          const acknowledgement = "Claro, repetiré la pregunta.";
          this.setState({ status: 'speaking' });
          await this.speakAssistant(acknowledgement, sessionId);
          if (this.sessionId !== sessionId) return;
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

          if (!validation.valid) {
            if (this.state.retryCount < MAX_RETRIES) {
              const retryNum = this.state.retryCount + 1;
              this.setState({ retryCount: retryNum });

            const explanation = validation.explanation || this.getGenericExplanation(question.type);
            const escalation = retryNum === 2 ? " Let's try once more." : "";
            const clarification = explanation + escalation;

              await this.speakAssistant(clarification, sessionId);
              if (this.sessionId !== sessionId) return;
              return this.askQuestion(questionIndex, { preserveRetryCount: true, retryCountOverride: retryNum });
            }

          await this.speakAssistant("Pasemos a la siguiente pregunta.", sessionId);
          if (this.sessionId !== sessionId) return;
          this.state.answers[question.id] = spokenAnswer;
          return this.advanceToNextQuestion(questionIndex, spokenAnswer);
        }

        const normalizedAnswer = validation.normalized;
        let cleanedAnswer = question.type === 'open'
          ? this.stripAcknowledgementPrefix(normalizedAnswer)
          : normalizedAnswer;
        if (question.id === 'cust_id_gender') {
          const genderValue = this.normalizeGenderValue(cleanedAnswer);
          if (genderValue) {
            cleanedAnswer = genderValue;
          }
        }
        this.state.answers[question.id] = cleanedAnswer;

        await this.speakAssistant("Gracias.", sessionId);
        if (this.sessionId !== sessionId) return;

        this.advanceToNextQuestion(questionIndex, cleanedAnswer);
      }

      getGenericExplanation(questionType) {
        switch (questionType) {
          case 'yes_no':
            return 'Por favor responda con un claro sí o no.';
          case 'date':
            return 'Por favor proporcione una fecha.';
          case 'number':
            return 'Por favor proporcione un número.';
          case 'choice':
            return 'Por favor elija una de las opciones.';
          case 'open':
          default:
            return 'Por favor proporcione una respuesta válida.';
        }
      }

      advanceToNextQuestion(currentIndex, answer) {
        const question = QUESTIONS[currentIndex];
        let nextIndex;

        if (question.onNo && answer === 'NO') {
          nextIndex = this.handleSkipTo(question.onNo, currentIndex, this.state.answers);
        } else {
          nextIndex = this.findNextQuestionIndex(currentIndex + 1, this.state.answers);
        }

        this.askQuestion(nextIndex);
      }

      async start() {
        this.sessionId += 1;
        const sessionId = this.sessionId;
        this.setState({
          status: 'speaking',
          currentQuestionIndex: -1,
          answers: {},
          transcript: [],
          retryCount: 0,
          explainCounts: {},
          lastWhyExplanation: null,
          pendingAssistantMessage: null,
          error: null,
        });

        await this.speakAssistant(INTRO_MESSAGE, sessionId);
        if (this.sessionId !== sessionId) return;

        const firstIndex = this.findNextQuestionIndex(0, {});
        this.askQuestion(firstIndex);
      }

      stop() {
        this.sessionId += 1;
        this.tts.stop();
        this.asr.stop();
        this.setState({ status: 'idle', pendingAssistantMessage: null });
      }
    }

    // ============================================================================
    // UI RENDERER
    // ============================================================================
    
    const controller = new FlowController();

    function render(state) {
      const app = document.getElementById('app');
      const question = state.currentQuestionIndex >= 0 && state.currentQuestionIndex < QUESTIONS.length
        ? QUESTIONS[state.currentQuestionIndex]
        : null;
      
      const progress = state.currentQuestionIndex >= 0
        ? Math.min(100, Math.round(((state.currentQuestionIndex + 1) / QUESTIONS.length) * 100))
        : 0;

      app.innerHTML = `
        <!-- Header -->
        <header class="sticky top-0 z-10">
          <div class="bg-white border-b border-[var(--brand-border)] px-6 py-2">
            <div class="max-w-6xl mx-auto flex items-center justify-between text-[var(--brand-primary)] text-sm font-semibold">
              <span>Protective Life</span>
              <span>Prototipo de aplicación de voz con inteligencia artificial</span>
            </div>
          </div>
          <div class="bg-[var(--brand-primary)] px-6 py-4">
            <div class="max-w-6xl mx-auto flex items-center justify-between text-white">
              <div class="flex items-center gap-4">
                <img src="logo.svg" alt="Protective Life logo" class="h-8 w-auto" />
                <div>
                  <h1 class="text-xl font-bold">Cuestionario de historial médico</h1>
                  <p class="text-sm text-white/80">Solicitud de seguro</p>
                </div>
              </div>
              ${state.status !== 'idle' && state.status !== 'complete' && question ? `
                <div class="text-right">
                  <div class="text-sm font-semibold">${question.section}</div>
                  <div class="text-xs text-white/70">Pregunta ${state.currentQuestionIndex + 1} of ${QUESTIONS.length}</div>
                </div>
              ` : ''}
            </div>
          </div>
        </header>

        <!-- Progress -->
        ${state.status !== 'idle' ? `
          <div class="bg-white px-6 py-2 border-b border-[var(--brand-border)]">
            <div class="max-w-6xl mx-auto">
              <div class="flex justify-between text-xs text-[var(--brand-text-secondary)] mb-1">
                <span>Progreso</span>
                <span>${progress}%</span>
              </div>
              <div class="w-full bg-gray-200 rounded-full h-1.5">
                <div class="bg-[var(--brand-primary)] h-1.5 rounded-full transition-all duration-500"
                     style="width: ${progress}%"></div>
              </div>
            </div>
          </div>
        ` : ''}

        <!-- Main -->
        <main class="max-w-6xl mx-auto px-6 py-12">
          <div class="flex gap-8">
            <div class="flex-1">
              ${state.status === 'idle' ? renderIdle(state) : ''}
              ${['speaking', 'listening', 'validating'].includes(state.status) ? renderActive(state, question) : ''}
              ${state.status === 'handoff' ? renderHandoff() : ''}
              ${state.status === 'complete' ? renderComplete(state) : ''}
            </div>
            ${['idle', 'complete', 'handoff'].includes(state.status) ? '' : renderChatFeed(state)}
          </div>
        </main>
      `;

      // Event handlers
      document.getElementById('startBtn')?.addEventListener('click', () => controller.start());
      document.getElementById('endBtn')?.addEventListener('click', () => controller.stop());
      document.getElementById('restartBtn')?.addEventListener('click', () => {
        controller.state = { ...controller.state, status: 'idle' };
        render(controller.state);
      });

      const chatScroll = document.getElementById('chatScroll');
      if (chatScroll) {
        chatScroll.scrollTop = chatScroll.scrollHeight;
      }
    }

    function renderIdle(state) {
      const isSupported = new ASRService().isSupported();

      return `
        <div class="text-center">
          <div class="mb-8">
            <div class="w-40 h-40 mx-auto bg-[var(--brand-primary)] rounded-full flex items-center justify-center mb-8 shadow-xl">
              <svg class="w-20 h-20 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                      d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
              </svg>
            </div>
            <h2 class="text-3xl font-bold mb-4">Listo para comenzar</h2>
            <p class="text-[var(--brand-text-secondary)] mb-8 max-w-lg mx-auto leading-relaxed">
              Este cuestionario le hará preguntas sobre su historial médico mediante interacción por voz.
Por favor, asegúrese de estar en un entorno tranquilo y hable con claridad.
            </p>
          </div>

          <button id="startBtn" 
                  class="px-10 py-4 bg-[var(--brand-primary)] hover:bg-[var(--brand-secondary)] 
                         rounded-full text-lg font-semibold text-white transition-all shadow-xl 
                         hover:scale-105">
            Iniciar aplicación
          </button>

          ${!isSupported ? `
            <div class="mt-6 p-4 bg-white border border-[var(--brand-border)] rounded-xl max-w-md mx-auto shadow-xl">
              <p class="text-[var(--brand-text-secondary)] text-sm">
                ⚠️ Voice recognition is not supported in this browser. Please use Chrome or Edge.
              </p>
            </div>
          ` : ''}

          ${state.error ? `
            <div class="mt-6 p-4 bg-white border border-red-300 rounded-xl max-w-md mx-auto shadow-xl">
              <p class="text-red-600 text-sm">${state.error}</p>
            </div>
          ` : ''}

        </div>
      `;
    }

    function renderActive(state, question) {
      const configs = {
        speaking: {
          color: 'bg-[var(--brand-primary)]',
          shadow: 'shadow-xl',
          label: 'Discurso',
          sublabel: 'Por favor, escuche la pregunta.',
        },
        listening: {
          color: 'bg-[var(--brand-secondary)]',
          shadow: 'shadow-xl',
          label: 'Escuchando',
          sublabel: 'Por favor, diga su respuesta con claridad.',
        },
        validating: {
          color: 'bg-[var(--brand-highlight)]',
          shadow: 'shadow-xl',
          label: 'Tratamiento',
          sublabel: 'Analizando tu respuesta con inteligencia artificial.',
        },
      };
      
      const cfg = configs[state.status];

      return `
        <div class="text-center">
          <!-- Status Indicator -->
          <div class="mb-10">
            <div class="w-40 h-40 mx-auto ${cfg.color} rounded-full flex items-center justify-center mb-8 
                        ${cfg.shadow} ${state.status !== 'validating' ? 'pulse-ring' : ''}">
              ${state.status === 'speaking' ? `
                <div class="flex items-center gap-1">
                  ${[1,2,3,4,5].map(() => `<div class="w-1.5 bg-white rounded-full sound-bar"></div>`).join('')}
                </div>
              ` : state.status === 'listening' ? `
                <svg class="w-20 h-20 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                        d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                </svg>
              ` : `
                <svg class="w-16 h-16 text-white animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                        d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
              `}
            </div>
            <h2 class="text-2xl font-bold mb-2">${cfg.label}</h2>
            <p class="text-[var(--brand-text-secondary)]">${cfg.sublabel}</p>
          </div>

          <!-- Current Question -->
          ${question ? `
            <div class="bg-white rounded-xl p-8 mb-10 max-w-2xl mx-auto border-t-4 border-[var(--brand-primary)] shadow-xl">
              <p class="text-xl leading-relaxed">${question.question}</p>
              ${question.type === 'yes_no' ? `
                <p class="text-sm text-[var(--brand-text-secondary)] mt-4">Por favor, responda sí o no.</p>
              ` : ''}
              ${question.type === 'choice' && question.choices ? `
                <p class="text-sm text-[var(--brand-text-secondary)] mt-4">Options: ${question.choices.join(', ')}</p>
              ` : ''}
            </div>
          ` : ''}

          <!-- Retry indicator -->
          ${state.retryCount > 0 ? `
            <p class="text-[var(--brand-text-secondary)] text-sm mb-6">Intentar ${state.retryCount + 1} de ${MAX_RETRIES + 1}</p>
          ` : ''}

          <!-- End Call Button -->
          <button id="endBtn" 
                  class="px-8 py-3 bg-white text-red-600 border border-red-300 hover:border-red-400 rounded-full font-semibold transition-colors shadow-sm">
            Finalizar llamada
          </button>
        </div>
      `;
    }

    function renderComplete(state) {
      const summaryItems = Object.entries(state.answers).map(([id, answer]) => {
        const q = QUESTIONS.find(q => q.id === id);
        return `
          <div class="flex justify-between py-3 border-b border-gray-200 last:border-0">
            <span class="text-[var(--brand-text-secondary)] text-sm flex-1 pr-4">${q?.question || id}</span>
            <span class="font-medium text-sm text-right max-w-[200px]">${answer}</span>
          </div>
        `;
      }).join('');

      return `
        <div class="text-center">
          <div class="w-32 h-32 mx-auto bg-[var(--brand-primary)] rounded-full 
                      flex items-center justify-center mb-8 shadow-xl">
            <svg class="w-16 h-16 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
            </svg>
          </div>
          <h2 class="text-3xl font-bold mb-4">Application Complete</h2>
          <p class="text-[var(--brand-text-secondary)] mb-10 max-w-lg mx-auto">
            Thank you for completing the questionnaire. Your responses have been recorded.
          </p>

          <!-- Summary -->
          <div class="bg-white rounded-xl p-6 max-w-2xl mx-auto text-left border-t-4 border-[var(--brand-primary)] shadow-xl">
            <h3 class="font-semibold mb-4 text-lg">Response Summary</h3>
            <div class="max-h-96 overflow-y-auto">
              ${summaryItems || '<p class="text-[var(--brand-text-secondary)]">No responses recorded</p>'}
            </div>
          </div>

          <button id="restartBtn" 
                  class="mt-10 px-8 py-3 bg-[var(--brand-primary)] hover:bg-[var(--brand-secondary)] 
                         text-white rounded-full font-semibold transition-all shadow-xl">
            Start New Application
          </button>
        </div>
      `;
    }

    function renderHandoff() {
      return `
        <div class="text-center">
          <div class="w-32 h-32 mx-auto bg-[var(--brand-primary)] rounded-full 
                      flex items-center justify-center mb-8 shadow-xl">
            <svg class="w-16 h-16 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <h2 class="text-3xl font-bold mb-4">Agent Handoff Requested</h2>
          <p class="text-[var(--brand-text-secondary)] mb-10 max-w-lg mx-auto">
            We can connect you with an agent to finish this question.
          </p>
          <button id="restartBtn" 
                  class="mt-4 px-8 py-3 bg-[var(--brand-primary)] hover:bg-[var(--brand-secondary)] 
                         text-white rounded-full font-semibold transition-all shadow-xl">
            Start Over
          </button>
        </div>
      `;
    }

    function renderTranscript(state) {
      const transcriptHtml = state.transcript.map(entry => `
        <div class="py-2 ${entry.role === 'user' ? 'text-blue-400' : 'text-slate-300'}">
          <span class="font-semibold text-xs uppercase tracking-wide opacity-60">
            ${entry.role === 'user' ? 'User' : 'System'}:
          </span>
          <span class="ml-2">${entry.text}</span>
        </div>
      `).join('');

      return `
        <div class="fixed bottom-4 right-4 z-50">
          <details class="bg-slate-900/95 backdrop-blur rounded-lg border border-slate-700 shadow-xl max-w-md">
            <summary class="px-4 py-2 cursor-pointer text-slate-400 hover:text-white text-sm">
              📝 Transcript (${state.transcript.length})
            </summary>
            <div class="px-4 pb-4 max-h-64 overflow-y-auto text-sm">
              ${transcriptHtml}
            </div>
          </details>
        </div>
      `;
    }

    function renderChatFeed(state) {
      const bubbleHtml = state.transcript.map(entry => {
        const isUser = entry.role === 'user';
        const bubbleClass = isUser
          ? 'bg-[var(--brand-primary)] text-white rounded-2xl rounded-br-sm'
          : 'bg-gray-200 text-[var(--brand-text)] rounded-2xl rounded-bl-sm';
        const alignClass = isUser ? 'justify-end' : 'justify-start';

        return `
          <div class="flex ${alignClass}">
            <div class="max-w-[220px] px-4 py-2 text-sm leading-relaxed ${bubbleClass}">
              ${entry.text}
            </div>
          </div>
        `;
      }).join('');

      const showUserTyping = state.status === 'listening' && state.transcript.length > 0;
      const showSystemTyping = state.status === 'validating' && state.transcript.length > 0;

      const typingDots = (alignRight) => `
        <div class="flex ${alignRight ? 'justify-end' : 'justify-start'}">
          <div class="flex items-center gap-1 px-4 py-2 rounded-2xl ${alignRight ? 'bg-[var(--brand-primary)]' : 'bg-gray-200'}">
            <span class="w-1.5 h-1.5 rounded-full ${alignRight ? 'bg-white/80' : 'bg-[var(--brand-text-secondary)]'} animate-bounce [animation-delay:-0.2s]"></span>
            <span class="w-1.5 h-1.5 rounded-full ${alignRight ? 'bg-white/80' : 'bg-[var(--brand-text-secondary)]'} animate-bounce [animation-delay:-0.1s]"></span>
            <span class="w-1.5 h-1.5 rounded-full ${alignRight ? 'bg-white/80' : 'bg-[var(--brand-text-secondary)]'} animate-bounce"></span>
          </div>
        </div>
      `;

      return `
        <aside class="w-80 shrink-0">
          <div class="bg-white border-t-4 border-[var(--brand-primary)] rounded-3xl p-4 shadow-xl h-[520px] flex flex-col">
            <div class="flex items-center gap-3 pb-4 border-b border-gray-200">
              <div class="w-10 h-10 rounded-full bg-[var(--brand-primary)] flex items-center justify-center">
                <span class="text-sm font-semibold text-white">AI</span>
              </div>
              <div>
                <div class="text-sm font-semibold">Asistente de suscripción</div>
                <div class="text-xs text-[var(--brand-text-secondary)]">Transcripción de la demostración en vivo</div>
              </div>
            </div>
            <div id="chatScroll" class="flex-1 overflow-y-auto space-y-3 py-4 pr-1">
              ${bubbleHtml || '<div class="text-[var(--brand-text-secondary)] text-sm">La conversación aparecerá aquí.</div>'}
              ${showUserTyping ? typingDots(true) : ''}
              ${state.pendingAssistantMessage ? typingDots(false) : ''}
              ${showSystemTyping && !state.pendingAssistantMessage ? typingDots(false) : ''}
            </div>
            <div class="pt-3 border-t border-gray-200">
              <div class="bg-[var(--brand-background)] rounded-xl px-4 py-3 text-[var(--brand-text-secondary)] text-xs">
                Voice mode enabled
              </div>
            </div>
          </div>
        </aside>
      `;
    }

    // Initialize
    async function init() {
      await loadConfig();
      controller.onStateChange = render;
      render(controller.state);
    }

    init();
  </script>
</body>
</html>
